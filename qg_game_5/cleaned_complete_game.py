#!/usr/bin/env python3

import arcade
import numpy
from pygame import mixer
import arcade.text as text
import sim_for_game as sim
import time

# A list of individuals generated by the simulation
pop = sim.starter_list

# A 'population' objected that holds important values generated by simulation
pop_keeper = sim.pop_holder

# Gives the beginning mean upon which the pokemon will be based
starting_mean = pop_keeper.mean_phenotypic_trait_value_list[0]

# Constants for scaling the images used for the pokemon
bulbasaur_scaling = 0.01
charmander_scaling = 0.01
squirtle_scaling = 0.02

# Creates a dictionary to easily access the scale values
scale_dict = {
	"bulbasaur" : bulbasaur_scaling,
	"charmander" : charmander_scaling,
	"squirtle" : squirtle_scaling

}

# Sets a scalar constant for variance (otherwise, characters get too big/small)
var_scalar = 0.03

# Constants for screen
SCREEN_WIDTH = 1500
SCREEN_HEIGHT = 1200
SCREEN_TITLE = "Jake's Platformer"

# Set default textures
TEXTURE_LEFT = 0
TEXTURE_RIGHT = 1




# Constants used to scale stationary objects
CLOUD_SCALING = 0.05
MOUNTAIN_SCALING = 0.5
BOUNDARY_TREE_SCALING = 0.40


TILE_SCALING = 0.5
GYARADOS_SCALING = 0.1

# Set the speed at which the character increments
ORGANISM_MEAN_MOVEMENT_SPEED = 20
JUMP_SPEED = 15
ENEMY_MOVEMENT_SPEED = 3

# Controls how fast the character returns to the ground after jumping or "flying" (i.e. traveling upward at a rate)
GRAVITY = 1.0

ENEMY_GRAVITY = 0.5

level = 1

# How many pixels to keep as a minimum margin between the character
# and the edge of the screen

# 6/8 is used for my Mac OS X, but it may need to be adjusted for Windows or Linux
LEFT_VIEWPORT_MARGIN = SCREEN_WIDTH * (6/8)
RIGHT_VIEWPORT_MARGIN = SCREEN_WIDTH * (6/8)
BOTTOM_VIEWPORT_MARGIN = 100
TOP_VIEWPORT_MARGIN = 350



# Keep a dictionary of all the stages/progression of the game

stage_dict = {
	'0' : "PREOPENING",
	'1' : "OPENING",
	'2' : "OPENING_RUNNING"
}



class MyGame(arcade.Window):
	"""
	Main application class.
	"""

	def __init__(self):

		# Call the parent class and set up the window
		super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

		# These are lists that keep track of all sprites--every sprite should have a list, 
		# and that listed should probably be based on what the sprite can/can't do

		self.wall_list = None
		self.player_list = None
		self.darwin_list = None
		self.enemy_list = None
		self.starters_list = None
		self.master_sprite_list = None

		# A series of switches that allow for transition between phases at the beginning
		# of the game
		self.pre_intro_1_started = False
		self.pre_intro_2_started = False

		# Initializes character scaling; this will be a number multiplied by a constant and the mean/variance/std_dev
		self.CHARACTER_SCALING = ""

		# This variable doesn't need to be called; it just serves to initalize the mixer by existing
		self.initialize_mixer = mixer.init()

		# Imports music tracks to be used at different points in the game
		self.intro_music = 'sounds/fairy_fountain_intro.wav'
		self.game_music = 'sounds/Night_Riding.wav'
		self.love_music = 'sounds/love.wav'

		# Select sound
		self.select = arcade.load_sound("sounds/select.wav")

		# HAY sound
		self.HAY = arcade.load_sound("sounds/Hay.wav")

		self.HAY_played = False

		# Represents whichever song is currently playing; default is introductory fairy-fountain music
		self.current_music = mixer.music.load(self.intro_music)

		# The pokemon that scroll through the opening screen above "Quantitative Genetics of Pokemon"
		self.intro_pokemon = None
		self.intro_venusaur = None
		self.intro_charizard = None
		self.intro_gyarados = None

		# Holds a sprite that carries the "Jake Botello presents" at the intro
		self.jake = None

		# A list to hold the jakesprite
		self.intro_list = None

		# Keeps track of which proportions of the population died
		self.loss_list = []
		self.pop_0_alive = True
		self.pop_1_alive = True
		self.pop_2_alive = True
		self.pop_3_alive = True
		self.pop_4_alive = True
		self.pop_5_alive = True
		self.pop_6_alive = True
		self.pop_7_alive = True
		self.pop_8_alive = True
		self.pop_9_alive = True

		# A switch for breeding
		self.breeding = False

		# Holds AN enemy sprite that can be used for debugging
		self.enemy = None

		# Holds the "darwin" sprite rendered for dialogue and (sometimes, possibly) the flag at the end of the level
		self.darwin_sprite = None

		# Sets the current state of the game; defaults to "PREOPENING", which walks through Jake presents, Warlak production, etc
		self.current_state = 0

		# Offers up the images to be used for the starter pokemon based on the user's choice
		self.starter_organism_dict = {
		"bulbasaur" : "images/bulbasaur_left.png",
		    "charmander" : "images/charmander_left.png",
		    "squirtle" : "images/squirtle_left.png"

		}

		# Holds the starting organism; charizard is by default to show (for debugging) when things aren't working
		self.starter_organism = "images/player_1/clean_charizard.png"

		# Used to recognize the starting pokemon chosen by the user
		self.starter_string = ""


		# Attributes used to keep track of which organism is being followed on the screen
		self.focal_organism = ""

		# Keeps track of the column you selected from to choose your starting focus
		self.column_choice = 0

		# A list that keeps track of all pokemon available to become focal organisms
		self.focal_organism_list = []

		# The current level
		self.level = level

		# Sets the background screen fade
		self.fade_stage_1 = False
		self.fade_stage_2 = False
		self.fade_stage_3 = False
		self.fade_stage_4 = False
		self.fade_stage_5 = False
		self.fade_stage_6 = False
		self.fade_stage_7 = False
		self.fade_stage_8 = False
		self.fade_stage_9 = False
		self.fade_stage_10 = False
		self.fade_stage_11 = False
		self.quick_sunset = False

		# Sets the default values of these colors to be changed
		self.fade_blue = 238
		self.fade_green = 149
		self.fade_red = 100

		# Sets up a floor for the histogram characters; ### CHANGE THIS NAME ###
		self.hist_floor = ""

		# Checks to see if the level is complete
		self.level_complete = False

		# Lets us know we're ready to go to the next level
		self.go_to_next_level = False

		# Switches on while histogram is being generated
		self.making_histogram = False

		# If this is true, begin the debriefing process
		self.debriefing = False

		# Switches extinction on and ends the game
		self.extinction = False

		self.new_mean = 0

		# Used in analog sunset method; holds the start time to be compared to the current time
		self.start_time = ""

		# Toggles the breeding event on/off
		self.ready_to_breed = False

		# Used to keep track of our scrolling
		self.view_bottom = 0
		self.view_left = 0

		 # Sets the background color--there are lots of options available through the arcade site
		arcade.set_background_color((0, 0, 0))

############################# INIT METHOD HAS BEEN CLEANED #############################


	def setup(self, level=1, CHARACTER_SCALING = starting_mean):
		""" Set up the game here. Call this function to restart the game. """

		######### RELATED TO SCREEN CREATION ##############

		# Used to keep track of our scrolling
		self.view_bottom = 0
		self.view_left = 0

		# Designate the "floor" for the histogram characters ###### CHANGE NAME #########
		self.hist_floor = 70


		# Represents the end of the level--Darwin/a flag goes here!
		self.end_of_level = self.level * 1000

		# A switch to use to position all sprites in their proper places just ONCE
		self.sprites_positioned = False

		######## REDEFINE ALL IMPORTANT LISTS AS SPRITELISTS #######

		# Note: SpriteList class instances have properties different from normal lists, e.g. no indexes

		# Create a master list to hold all sprite lists
		self.master_sprite_list = []

		# Create the Sprite lists
		self.player_list = arcade.SpriteList()
		self.wall_list = arcade.SpriteList()
		self.enemy_wall_list = arcade.SpriteList()
		self.enemy_list = arcade.SpriteList()
		self.darwin_list = arcade.SpriteList()

		# Append small lists to master sprite list
		self.master_sprite_list.append(self.player_list)
		self.master_sprite_list.append(self.wall_list)
		self.master_sprite_list.append(self.enemy_wall_list)
		self.master_sprite_list.append(self.enemy_list)
		self.master_sprite_list.append(self.darwin_list)

		self.played = False

		# A standard list to hold all potential organisms in focus
		self.focal_organism_list = []

		# A standard list ot hold all enemy physics engines
		self.enemy_physics_engine_list = []


		######### RELATED TO ENVIRONMENT CREATION ##########

		### DRAW THE GROUND ###
		for x in range(-500, 10000, 64):
			# Chooses an image to load as the "floor"
			##### CHANGE THIS BASED ON USER INPUT #####
			wall = arcade.Sprite("images/tiles/grassMid.png", TILE_SCALING)

			# Continues drawing this image over and over at intervals of '64'...
			# ...for the duration of this for loop (currently set at 10,000 as an x-distance to travel)
			wall.center_x = x

			# Sets the center of the image at height '10'
			wall.center_y = 10

			# Makes the floor a part of "wall_list", which interacts with players via gravity/physics, etc
			self.wall_list.append(wall)

			# Be sure this also gets added to enemy wall list, which may have different rules than the player walls
			self.enemy_wall_list.append(wall)


		### DRAW THE SKY ###
		for x in range(-500, 10000, 64):
		# Sets the sky as clouds ### LET USER INPUT CHANGE THIS ###
			wall = arcade.Sprite("images/tiles/cloud.png", CLOUD_SCALING)

			# Same rules apply as for ground; goes on indefinitely based on x-argument (10,000, here)
			wall.center_x = x

			# Starts around the top of the viewport for the user
			wall.center_y = 530

			# This is relevant for the player, so it's on wall_list
			self.wall_list.append(wall)

			# This is relevant for the enemy, so it's on enemy_wall_list
			self.enemy_wall_list.append(wall)

		### BOUNDARY LEFT IMAGE ####
		# Makes a giant 'boundary tree' that prevents characters from walking (left) off the face of the Earth
		tree = arcade.Sprite("images/tiles/boundary_tree.png", BOUNDARY_TREE_SCALING)

		# Sets this tree at -350 = x and 265 = y (about the height of the 'sky'/clouds/forest trees)
		tree.center_x = -300
		tree.center_y = 250

		# This tree is only relevant to players (it doesn't affect enemies), so we'll only append...
		# ...it to wall list
		self.wall_list.append(tree)


		### SET UP MOUNTAIN ###

		# This sets up a mountain as a climbing obstacle if smaller organisms are being (deliberately)...
		# ...given a hard time
		mountain = arcade.Sprite("images/mountain.png", MOUNTAIN_SCALING)

		# Gives the mountain coordinates based on random generation
		mountain.center_x = numpy.random.randint(200, self.end_of_level)
		mountain.center_y = self.hist_floor

		# Adds the mountain to the wall lists (it's treated as a wall in physics engines)
		self.wall_list.append(mountain)
		self.enemy_wall_list.append(mountain)


		### SET UP ROCKS/OBSTACLES ###

		# Minimum x/y coordinates for rocks/obstacles
		rock_range_min = [200, self.hist_floor+40]

		# Maximum x/y coordinates for rocks/obstacles
		rock_range_max = [self.end_of_level*self.level, self.hist_floor + 100]

		# Makes however many rocks you want (range)
		for coordinate in range(self.level*10):

			# Uses numpy to randomly generated coordinates within the min/max shown above
			x_coordinate = numpy.random.randint(rock_range_min[0], rock_range_max[0]) 
			y_coordinate = numpy.random.randint(rock_range_min[1], rock_range_max[1])

			# Makes it an object to append to the wall_list
			rock = arcade.Sprite("images/rock.png", TILE_SCALING)

			# Gets a position randomly assigned above
			rock.position = [x_coordinate, y_coordinate]

			# Adds to the wall lists (player and enemy, respectively)
			self.wall_list.append(rock)
			self.enemy_wall_list.append(rock)


		# This is the minimum height of an object generated above the ground
		# This should scale to a certain member of the population
		# It's at 150 now but should change!
		level_y_boundary = 150

		# This adds it to the floor so that it includes the ground in the calculation
		level_y_boundary = level_y_boundary + self.hist_floor





		######### RELATED TO INTRODUCTORY PHASES ###########

		# Holds the jake sprite
		self.intro_list = arcade.SpriteList()

		# Append jakelist to master sprite list
		self.master_sprite_list.append(self.intro_list)

		# Holds 'Jake Presents' message
		self.jake = arcade.Sprite("images/jakepresents.png", scale=0.5)

		# Append to Jakelist
		self.intro_list.append(self.jake)

		# Stays on while Jake has not fully faded-in
		self.jake.fading_in = True

		# Demonstrates that Jake is totally faded-in (### CAN BE SUBSTITUTED FOR JAKE FADE_COUNT 
		# IN PREVIOUS ITERATION ###)
		self.jake.faded = False

		# Holds the texture that allows "Jake" to transform into the warlak image
		# for the second introductory page
		self.jake.textures = []

		# Load the warlak texture for use
		texture = arcade.load_texture("images/warlak3.png", scale=0.5)

		# Add warlak texture to texture list
		self.jake.textures.append(texture)

		# The "Quantitative Genetics of Pokemon" Banner-Sprite
		self.qg_pokemon = arcade.Sprite("images/qg_pokemon.png", scale = 0.5)

		# Append to introductory list
		self.intro_list.append(self.qg_pokemon)

		# Switch for drawing opening screen
		self.jake_intro = False

		# Switch for beginning game
		self.start_game = False

		# A switch to keep the breeding histogram from being drawn a thousand times
		self.breeding_histogram_drawn = False

		# Holds all the pokemon rotated through in introductory screen
		self.intro_pokemon = []
		# Loads pokemon used in introductory screen
		self.intro_gyarados = arcade.Sprite("images/intro_pokemon/gyarados_left.png", scale = 0.4)
		self.intro_charizard = arcade.Sprite("images/intro_pokemon/clean_charizard.png", scale = 0.4)
		self.intro_venusaur = arcade.Sprite("images/intro_pokemon/venusaur.png", scale = 0.25)

		# Appends pokemon to introductory list
		self.intro_pokemon.append(self.intro_venusaur)
		self.intro_pokemon.append(self.intro_charizard)
		self.intro_pokemon.append(self.intro_gyarados)

		# Adds attributes to intro pokemon to allow them to fade in/out
		for i in self.intro_pokemon:
			i.fading_in = True
			i.fading_out = False



		############# OAK AND DARWIN DIALOGUE PHASES ################

		# Music played while Professor Oak and Darwin are speaking in the greeting
		self.pokemon_medley = "sounds/pokemon_medley.wav"

		# Creates a Darwin sprite--he currently doubles as a speaker AND the end of the level (CHANGE)
		self.darwin_sprite = arcade.Sprite("images/darwin.png")

		# Path of the sound Darwin plays when he enters (annoyed)
		self.darwin_sprite.sound_effect_annoyed = "sounds/darwin_annoyed.wav"

		# Load the sound Darwin plays when he enters
		self.darwin_annoyed_sound = arcade.load_sound(self.darwin_sprite.sound_effect_annoyed)

		# A switch to determine whether or not this sound has been played so it doesn't play infinitely
		self.darwin_sound_1_played = False

		# A switch to determine whether or not Darwin has been displaced
		self.darwin_sprite.displaced = False




		# Darwin Textures
		self.darwin_sprite.textures = []

		# Darwin facing right
		texture = arcade.load_texture("images/darwin.png", scale = 1)
		# Appended to list
		self.darwin_sprite.textures.append(texture)

		# Darwin facing left
		texture = arcade.load_texture("images/darwin.png", mirrored = True, scale = 1)

		# Appended to list
		self.darwin_sprite.textures.append(texture)

		# Sets Darwin to be facing left by default
		self.darwin_sprite.set_texture(1)

		# Sets Darwin up at the end of the level (currently 1200)
		self.darwin_sprite.center_x = self.end_of_level

		# Keeps Darwin on the ground
		self.darwin_sprite.center_y = 64

		# Appends Darwin to a list with himself in it (useful for checking collisions)
		self.darwin_list.append(self.darwin_sprite)

		# Creates a list to hold oak characters
		self.oak_sprite_list = arcade.SpriteList()

		# Loads the image of Professor Oak
		self.prof_oak = arcade.Sprite("images/prof_oak.png", 1)

		# Appends professor oak to his list
		self.oak_sprite_list.append(self.prof_oak)

		# Adds OakList to the master list
		self.master_sprite_list.append(self.oak_sprite_list)

		# A switch that says Professor Oak is speaking #### MAY BE DEPRECATED #####
		self.prof_oak_dialogue = False

		# A switch that says Darwin is speaking #### MAY BE DEPRECATED #####
		self.darwin_dialogue = False

		# If Professor Oak needs to respond to a button (or something else in the phase does)...
		# ...these keys keep track
		self.prof_oak_key_pressed_1 = False
		self.prof_oak_key_pressed_2 = False
		self.prof_oak_key_pressed_3 = False
		self.prof_oak_key_pressed_4 = False


		###### FIRST OAK AND DARWIN DIALOGUE EVENT (WELCOME/INTRODUCTIONS) ########

		# First set of dialogue images (9/9; numbers 4, 5, 7, and 8 are Darwin)
		self.oak1_m1_of_9 = arcade.Sprite("images/oak1/oak1-1.png")
		self.oak1_m2_of_9 = arcade.Sprite("images/oak1/oak1-2.png")
		self.oak1_m3_of_9 = arcade.Sprite("images/oak1/oak1-3.png")

		self.darwin1_m4_of_9 = arcade.Sprite("images/oak1/oak1-4.png")
		self.darwin1_m5_of_9 = arcade.Sprite("images/oak1/oak1-5.png")

		self.oak1_m6_of_9 = arcade.Sprite("images/oak1/oak1-6.png")

		self.darwin1_m7_of_9 = arcade.Sprite("images/oak1/oak1-7(revised).png")
		self.darwin1_m8_of_9 = arcade.Sprite("images/oak1/oak1-8.png")

		self.oak1_m9_of_9 = arcade.Sprite("images/oak1/oak1-9.png")




		# Creates a list to hold the first of Oak/Darwin's musings
		self.oak1_list = []

		# Appends images to list
		self.oak1_list.append(self.oak1_m1_of_9)
		self.oak1_list.append(self.oak1_m2_of_9)
		self.oak1_list.append(self.oak1_m3_of_9)
		self.oak1_list.append(self.darwin1_m4_of_9)
		self.oak1_list.append(self.darwin1_m5_of_9)
		self.oak1_list.append(self.oak1_m6_of_9)
		self.oak1_list.append(self.darwin1_m7_of_9)
		self.oak1_list.append(self.darwin1_m8_of_9)
		self.oak1_list.append(self.oak1_m9_of_9)


		###### SECOND OAK AND DARWIN DIALOGUE EVENT (SELECT A SPECIES) ########


		# Second set of dialogue images (5/5; 2 is Darwin, #5 has three options based on choice)
		self.oak2_m1_of_5 = arcade.Sprite("images/oak2/oak2-1.png")

		self.darwin2_m2_of_5 = arcade.Sprite("images/oak2/oak2-2.png")

		self.oak2_m3_of_5 = arcade.Sprite("images/oak2/oak2-3.png")
		self.oak2_m4_of_5 = arcade.Sprite("images/oak2/oak2-4.png")

		# Choose your starter pokemon and oak will respond appropriately
		self.oak2_m5charmander_of_5 = arcade.Sprite("images/oak2/oak2-5(charmander).png")
		self.oak2_m5squirtle_of_5 = arcade.Sprite("images/oak2/oak2-5(squirtle).png")
		self.oak2_m5bulbasaur_of_5 = arcade.Sprite("images/oak2/oak2-5(bulbasaur).png")

		# Makes the list to hold dialogue
		self.oak2_list = []

		# Appends images (messages) to list
		self.oak2_list.append(self.oak2_m1_of_5)
		self.oak2_list.append(self.darwin2_m2_of_5)
		self.oak2_list.append(self.oak2_m3_of_5)
		self.oak2_list.append(self.oak2_m4_of_5)
		self.oak2_list.append(self.oak2_m5charmander_of_5)
		self.oak2_list.append(self.oak2_m5squirtle_of_5)
		self.oak2_list.append(self.oak2_m5bulbasaur_of_5)


		###### THIRD OAK AND DARWIN DIALOGUE EVENT (SELECT A HISTOGRAM COLUMN) ########

		# Third set of dialogue images (6/6; #5 is Darwin)
		self.oak3_m1_of_6 = arcade.Sprite("images/oak3/oak3-1.png")
		self.oak3_m2_of_6 = arcade.Sprite("images/oak3/oak3-2.png")
		self.oak3_m3_of_6 = arcade.Sprite("images/oak3/oak3-3.png")
		self.oak3_m4_of_6 = arcade.Sprite("images/oak3/oak3-4.png")
		self.darwin3_m5_of_6 = arcade.Sprite("images/oak3/oak3-5.png")
		self.oak3_m6_of_6 = arcade.Sprite("images/oak3/oak3-6.png")

		# Makes a list to hold all dialogue images
		self.oak3_list = []

		# Appends all dialogue images to the list
		self.oak3_list.append(self.oak3_m1_of_6)
		self.oak3_list.append(self.oak3_m2_of_6)
		self.oak3_list.append(self.oak3_m3_of_6)
		self.oak3_list.append(self.oak3_m4_of_6)
		self.oak3_list.append(self.darwin3_m5_of_6)
		self.oak3_list.append(self.oak3_m6_of_6)



		###### FOURTH OAK AND DARWIN DIALOGUE EVENT ########

		self.oak4_m1a_of_3 = arcade.Sprite("images/oak4/oak4-1a.png")
		self.oak4_m1b_of_3 = arcade.Sprite("images/oak4/oak4-1b.png")
		self.oak4_m1c_of_3 = arcade.Sprite("images/oak4/oak4-1c.png")
		self.oak4_m1d_of_3 = arcade.Sprite("images/oak4/oak4-1d.png")
		self.oak4_m1e_of_3 = arcade.Sprite("images/oak4/oak4-1e.png")
		self.oak4_m1f_of_3 = arcade.Sprite("images/oak4/oak4-1f.png")
		self.oak4_m2_of_3 = arcade.Sprite("images/oak4/oak4-2.png")
		self.oak4_m3_of_3 = arcade.Sprite("images/oak4/oak4-3.png")

		# Creates a list to hold the fourth dialogue event's images
		self.oak4_list = []

		self.oak4_list.append(self.oak4_m1a_of_3)
		self.oak4_list.append(self.oak4_m1b_of_3)
		self.oak4_list.append(self.oak4_m1c_of_3)
		self.oak4_list.append(self.oak4_m1d_of_3)
		self.oak4_list.append(self.oak4_m1e_of_3)
		self.oak4_list.append(self.oak4_m1f_of_3)
		self.oak4_list.append(self.oak4_m2_of_3)
		self.oak4_list.append(self.oak4_m3_of_3)



		###### MASTER LIST OF ALL OAK/DARWIN DIALOGUE ########

		# This list contains all dialogue so that it can be easily modified at once
		# (i.e. through a for-loop)
		self.dialogue_master_list = []

		# Extends (rather than appending) each new list to make one gigantic, SINGLE list of dialogue messages
		self.dialogue_master_list.extend(self.oak1_list)
		self.dialogue_master_list.extend(self.oak2_list)
		self.dialogue_master_list.extend(self.oak3_list)
		self.dialogue_master_list.extend(self.oak4_list)

		# Applies effects to all messages at once
		for i in self.dialogue_master_list:
			# Starts every message out with a "fade-in"
			i.fading_in = True

			# This switch tells us when the message is ready to start losing opacity
			i.fading_out = False

			# Sets the scale of each message (this should be fixed at 0.4)
			i.scale = 0.4





###### BIOLOGICAL/QUANTITATIVE VALUES #####

		# The variance of the current generation
		self.var = pop_keeper.additive_genetic_variance_list[self.level-1]

		# The standard deviation of the current generation (square root of variance)
		self.std_dev = numpy.sqrt(self.var)

		############# DELETE IF NOT NECESSARY ###########
		#self.update_scaling(self.starter_string)

		# A switch used to make sure scaling is only updated ONCE...
		# ...and not with each update()
		self.scaling_updated = False

		# Checks to see if the effect of selection has been calculated this generation
		self.selection_calculated = False


		##### RELATED TO BREEDING EVENT ########

		# Creates a list to hold the hearts that'll go floating everywhere during random mating
		self.heart_list = arcade.SpriteList()

		# Add the heart list to the master sprite list
		self.master_sprite_list.append(self.heart_list)

		# A switch--tells us whether or not we're reading for the "fly-away" event/random mating
		self.honeymoon_ready = False


		# Generates all the little hearts that go swelling everywhere on the screen (50 now, but adjustable)
		for i in range(50):
			# Chooses an image for the hearts (modify by level, maybe?)
			heart = arcade.Sprite("images/heart.png", scale = 0.01)

			# Check to see the heart has been given a coordinate; by default, it hasn't
			heart.has_point = False

			# Check to see if the heart has already begun the process of swelling/shrinking
			# By default, it hasn't
			heart.growing = False

			# Add to the list of hearts
			self.heart_list.append(heart)


		# Check to see how many organisms have found a pair/match; starts at zero and increments up
		self.paired_count = 0

		# Holds the list of coordinates that organisms will occupy once they're ready for mating
		self.breeding_coordinates = []

		# Coordinates that've already been used by organisms--these should be getting moved over...
		# ...from "breeding coordinates"
		# You should be able to check to see that only coordinates that AREN'T in this list are...
		# ...getting picked by new organisms.
		self.used_coords = []






		#### EXPERIMENTAL: TRYING TO CREATE TEN DIFFERENT VARIANTS ACROSS A GRADIENT ####

		# Define an 'experimental' list (#### CHANGE NAME ####)
		self.experimental_list = arcade.SpriteList()

		# Define a list to hold only the histogram-drawn characters
		self.histogram_list = arcade.SpriteList()

		# Add the experimental list to the master sprite list
		self.master_sprite_list.append(self.experimental_list)



		########## RELATED TO ENEMY CONSTRUCTION ##############


		# Set up the predator's image and scaling
		self.enemy = arcade.Sprite("images/red_gyarados_right.png", GYARADOS_SCALING)



		# Sets the starting position of the enemy well-behind the player's starting position
		self.enemy.center_x = -150

		# Sets the enemy down on the ground
		self.enemy.center_y = 90

		##### MAKE ENEMIES ON A SCHEDULE; NEEDS WORK!!!!! #######
		#arcade.schedule(self.make_enemy, 5)

		# Adds the main enemy generated to the enemy_list
		self.enemy_list.append(self.enemy)

		for enemy in self.enemy_list:
			enemy.speed = numpy.random.randint(1, ENEMY_MOVEMENT_SPEED*2)



		#################### CREATE PHYSICS ENGINES ####################

		# Creates a physics engine list to hold all player engines
		self.player_physics_engines_list = []

		# Note: Player physics engines will be created in the "define all sprites" area

		# Creates a physics engine for a single enemy (if there's just one)
		self.physics_engine_enemy = arcade.PhysicsEnginePlatformer(self.enemy, self.enemy_wall_list, ENEMY_GRAVITY)

		# Adds the single-enemy physics-engine to the enemy physics-engine list
		self.enemy_physics_engine_list.append(self.physics_engine_enemy)

		# Gives Darwin a physics engine so that he can serve as the end of the level
		self.physics_engine_darwin = arcade.PhysicsEnginePlatformer(self.darwin_sprite, self.wall_list, GRAVITY)

		# Make a master physics engine list to hold all physics engines for easy updating
		self.master_physics_engine_list = []

		# Append darwin engine to list
		self.master_physics_engine_list.append(self.physics_engine_darwin)

		# Extend entire enemy/player physics engine list to master list
		self.master_physics_engine_list.extend(self.enemy_physics_engine_list)
		self.master_physics_engine_list.extend(self.player_physics_engines_list)


		# A final loop to apply effects to EVERY sprite at once during set-up:
		for sprite_list in self.master_sprite_list:
			for sprite in sprite_list:
				# Give every sprite the ability to fade in (default) and out
				sprite.fading_in = True
				sprite.fading_out = False


		############################# SETUP METHOD HAS BEEN CLEANED #############################

	def make_enemies(self, level):
		for i in range(level-1):
			new_enemy = arcade.Sprite("images/red_gyarados_right.png", GYARADOS_SCALING)
			new_enemy.physics_engine = arcade.PhysicsEnginePlatformer(new_enemy, self.enemy_wall_list, ENEMY_GRAVITY)
			self.enemy_list.append(new_enemy)
			self.enemy_physics_engine_list.append(new_enemy.physics_engine)
			new_enemy.center_x = -200
			new_enemy.center_y = self.hist_floor

		for enemy in self.enemy_list:
			enemy.speed = numpy.random.randint(1, ENEMY_MOVEMENT_SPEED*2)


	def define_all_ten_sprites_images(self):

		# Sets player_list equal to experimetal_list so that all changes to the latter affect the former
		self.player_list = self.experimental_list

		### Generates a sprite for each level of variation in the population ###
		### NOTE ABOUT DUMMY SPRITES ###
		# They're used only for the histogram--they stack atop the usable organism in
		# the experimental list

		if self.ready_to_breed == False:
			# Will lose 2 std_dev from mean
			self.organism_var1_sprite = arcade.Sprite(self.starter_organism)

			# Will lose 1.5 std_dev from mean
			self.organism_var2_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var2_dummy1 = arcade.Sprite(self.starter_organism)

			# Will lose 1 std_dev from mean
			self.organism_var3_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var3_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var3_dummy2 = arcade.Sprite(self.starter_organism)

			# Will lose 0.5 std_dev from mean
			self.organism_var4_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy3 = arcade.Sprite(self.starter_organism)

			# Will lose 0.25 std_dev from mean
			self.organism_var5_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy3 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy4 = arcade.Sprite(self.starter_organism)

			# Will gain 0.25 std_dev from mean
			self.organism_var6_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy3 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy4 = arcade.Sprite(self.starter_organism)


			# Will gain 0.5 std_dev from mean
			self.organism_var7_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy3 = arcade.Sprite(self.starter_organism)

			# Will gain 1 std_dev from mean
			self.organism_var8_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy3 = arcade.Sprite(self.starter_organism)

			# Will gain 1.5 std_dev from mean
			self.organism_var9_sprite = arcade.Sprite(self.starter_organism)
			self.organism_var9_dummy1 = arcade.Sprite(self.starter_organism)

			# Will gain 2 std_dev from mean
			self.organism_var10_sprite = arcade.Sprite(self.starter_organism)

		if self.ready_to_breed == True:
# Will lose 2 std_dev from mean
			self.organism_var1_dummy = arcade.Sprite(self.starter_organism)

			# Will lose 1.5 std_dev from mean
			self.organism_var2_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var2_dummy1 = arcade.Sprite(self.starter_organism)

			# Will lose 1 std_dev from mean
			self.organism_var3_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var3_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var3_dummy2 = arcade.Sprite(self.starter_organism)

			# Will lose 0.5 std_dev from mean
			self.organism_var4_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var4_dummy3 = arcade.Sprite(self.starter_organism)

			# Will lose 0.25 std_dev from mean
			self.organism_var5_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy3 = arcade.Sprite(self.starter_organism)
			self.organism_var5_dummy4 = arcade.Sprite(self.starter_organism)

			# Will gain 0.25 std_dev from mean
			self.organism_var6_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy3 = arcade.Sprite(self.starter_organism)
			self.organism_var6_dummy4 = arcade.Sprite(self.starter_organism)


			# Will gain 0.5 std_dev from mean
			self.organism_var7_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var7_dummy3 = arcade.Sprite(self.starter_organism)

			# Will gain 1 std_dev from mean
			self.organism_var8_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy1 = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy2 = arcade.Sprite(self.starter_organism)
			self.organism_var8_dummy3 = arcade.Sprite(self.starter_organism)

			# Will gain 1.5 std_dev from mean
			self.organism_var9_dummy = arcade.Sprite(self.starter_organism)
			self.organism_var9_dummy1 = arcade.Sprite(self.starter_organism)

			# Will gain 2 std_dev from mean
			self.organism_var10_dummy = arcade.Sprite(self.starter_organism)

		if self.ready_to_breed == False:
			# Append all to experimental list
			self.experimental_list.append(self.organism_var1_sprite)
			self.experimental_list.append(self.organism_var2_sprite)
			self.experimental_list.append(self.organism_var3_sprite)
			self.experimental_list.append(self.organism_var4_sprite)
			self.experimental_list.append(self.organism_var5_sprite)
			self.experimental_list.append(self.organism_var6_sprite)
			self.experimental_list.append(self.organism_var7_sprite)
			self.experimental_list.append(self.organism_var8_sprite)
			self.experimental_list.append(self.organism_var9_sprite)
			self.experimental_list.append(self.organism_var10_sprite)


		if self.ready_to_breed == False:
			print("Is this happening at the end somehow?")
		# Make a histogram list that contains all the same sprites but can have others (dummies) added
			self.histogram_list.append(self.organism_var1_sprite)
			self.histogram_list.append(self.organism_var2_sprite)
			self.histogram_list.append(self.organism_var3_sprite)
			self.histogram_list.append(self.organism_var4_sprite)
			self.histogram_list.append(self.organism_var5_sprite)
			self.histogram_list.append(self.organism_var6_sprite)
			self.histogram_list.append(self.organism_var7_sprite)
			self.histogram_list.append(self.organism_var8_sprite)
			self.histogram_list.append(self.organism_var9_sprite)
			self.histogram_list.append(self.organism_var10_sprite)

		# Append all dummies to the histogram list (which already has the regular sprites in it)
		
		if self.ready_to_breed == True:
			self.histogram_list = arcade.SpriteList()
			self.histogram_list.append(self.organism_var1_dummy)
			self.histogram_list.append(self.organism_var2_dummy)
			self.histogram_list.append(self.organism_var3_dummy)
			self.histogram_list.append(self.organism_var4_dummy)
			self.histogram_list.append(self.organism_var5_dummy)
			self.histogram_list.append(self.organism_var6_dummy)
			self.histogram_list.append(self.organism_var7_dummy)
			self.histogram_list.append(self.organism_var8_dummy)
			self.histogram_list.append(self.organism_var9_dummy)
			self.histogram_list.append(self.organism_var10_dummy)
		# Var 2 Organism Dummies
		self.histogram_list.append(self.organism_var2_dummy1)

		# Var 3 Organism Dummies
		self.histogram_list.append(self.organism_var3_dummy1)
		self.histogram_list.append(self.organism_var3_dummy2)

		# Var 4 Organism Dummies
		self.histogram_list.append(self.organism_var4_dummy1)
		self.histogram_list.append(self.organism_var4_dummy2)

		# Var 5 Organism Dummies
		self.histogram_list.append(self.organism_var5_dummy1)
		self.histogram_list.append(self.organism_var5_dummy2)
		self.histogram_list.append(self.organism_var5_dummy3)

		# Var 6 Organism Dummies
		self.histogram_list.append(self.organism_var6_dummy1)
		self.histogram_list.append(self.organism_var6_dummy2)
		self.histogram_list.append(self.organism_var6_dummy3)

		# Var 7 Organism Dummies
		self.histogram_list.append(self.organism_var7_dummy1)
		self.histogram_list.append(self.organism_var7_dummy2)

		# Var 8 Organism Dummies
		self.histogram_list.append(self.organism_var8_dummy1)
		self.histogram_list.append(self.organism_var8_dummy2)

		# Var 8 Organism Dummies
		self.histogram_list.append(self.organism_var9_dummy1)

		for i in self.histogram_list:
			i.mating_point = False
			i.point = ""
			i.paired_y = ""
			i.paired_x = ""

		for i in self.experimental_list:
			i.physics_engine = arcade.PhysicsEnginePlatformer(i, self.wall_list, GRAVITY)
			self.player_physics_engines_list.append(i.physics_engine)
			i.physics_engine.can_jump()
			i.jump = 0


        # Check to see which starter was chosen and change textures
		for i in self.experimental_list:

			# Gives the histogram column in which this organism resides; defaults to zero
			i.column = 0
            # If starter is bulbasaur, give bulbasaur textures
			if self.starter_string == "bulbasaur":
				pass
            	# Append left image
				#texture = arcade.load_texture("images/bulbasaur_left.png", scale = i.scale)
				#i.textures.append(texture)

				# Append right image
				#texture = arcade.load_texture("images/bulbasaur_right.png", scale = i.scale)
				#i.textures.append(texture)
				#print("We're bulbasaurs with our textures appended!")

			# If starter is charmander, give charmander textures
			elif self.starter_string == "charmander":
				pass
				# Append left image
				#texture = arcade.load_texture("images/charmander_left.png", scale = i.scale)
				#i.textures.append(texture)

				# Append right image
				#texture = arcade.load_texture("images/charmander_right.png", scale = i.scale)
				#i.textures.append(texture)
				#print("We're charmanders with our textures appended!")

            # If starter is squirtle, give squirtle textures
			elif self.starter_string == "squirtle":
				pass
				# Append left image
				#texture = arcade.load_texture("images/squirtle_left.png", i.scale)
				#i.textures.append(texture)

				# Append right image
				#texture = arcade.load_texture("images/squirtle_right.png", i.scale)
				#i.textures.append(texture)
				#print("We're squirtles with our textures appended!")



			# Look right by default
			#i.set_texture(TEXTURE_RIGHT)
			
			# Set all the textures to be equal in scale to the characters
			#for texture in i.textures:
			#	texture.scale = i.scale

			# Establishes that the organism, by default, isn't dead
			i.dead = False


	def position_player_sprites_in_game(self):
		for i in self.player_list:
			# If this organism isn't the focus, make it semi-transparent
			if i != self.focal_organism:
				i.alpha = 50
			# Place them at "zero"
			i.center_x = 0




############## DEFINE_ALL_TEN_SPRITES METHOD HAS BEEN CLEANED #############

	# Set everyone to their proper scalar values; note that this won't run properly
	# until a starter has been selected
	def scale_everyone(self):

		if self.starter_string:

			# Set all textures equal to the player's scale
			for i in self.player_list:

				for texture in i.textures:
					texture.scale = i.scale
			
			# Establish which type of scaling is appropriate by checking the starter string...
			# ...and retrieving the right scale
			appropriate_mean_scale = scale_dict[self.starter_string]

			# Set character scaling equal to the mean times the scalar constant
			self.CHARACTER_SCALING = appropriate_mean_scale * starting_mean

			# Prevents the variance from making characters overtake the screen
			self.var = self.var * var_scalar

			# Set the standard deviation equal to the square root of the variance
			self.std_dev = numpy.sqrt(self.var)

			# Give each character its appropriate amount of deviation from the mean

			# Var 1 Org
			self.organism_var1_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*2)

			# Var 2 org and dummy
			self.organism_var2_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*1.5)
			self.organism_var2_dummy1.scale = self.organism_var2_sprite.scale

			# Var 3 org and dummies
			self.organism_var3_sprite.scale = self.CHARACTER_SCALING - (self.std_dev)
			self.organism_var3_dummy1.scale = self.organism_var3_sprite.scale
			self.organism_var3_dummy2.scale = self.organism_var3_sprite.scale

			# Var 4 org and dummies
			self.organism_var4_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*0.5)
			self.organism_var4_dummy1.scale = self.organism_var4_sprite.scale
			self.organism_var4_dummy2.scale = self.organism_var4_sprite.scale


			self.organism_var5_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*0.25)
			self.organism_var5_dummy1.scale = self.organism_var5_sprite.scale
			self.organism_var5_dummy2.scale = self.organism_var5_sprite.scale
			self.organism_var5_dummy3.scale = self.organism_var5_sprite.scale


			self.organism_var6_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*0.25)
			self.organism_var6_dummy1.scale = self.organism_var6_sprite.scale
			self.organism_var6_dummy2.scale = self.organism_var6_sprite.scale
			self.organism_var6_dummy3.scale = self.organism_var6_sprite.scale

			self.organism_var7_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*0.5)
			self.organism_var7_dummy1.scale = self.organism_var7_sprite.scale
			self.organism_var7_dummy2.scale = self.organism_var7_sprite.scale

			self.organism_var8_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*1)
			self.organism_var8_dummy1.scale = self.organism_var8_sprite.scale
			self.organism_var8_dummy2.scale = self.organism_var8_sprite.scale

			self.organism_var9_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*1.5)
			self.organism_var9_dummy1.scale = self.organism_var9_sprite.scale

			self.organism_var10_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*2)

			if self.ready_to_breed == True:
				
				self.organism_var1_dummy.scale = self.organism_var1_sprite.scale
				self.organism_var2_dummy.scale = self.organism_var2_sprite.scale
				self.organism_var3_dummy.scale = self.organism_var3_sprite.scale
				self.organism_var4_dummy.scale = self.organism_var4_sprite.scale
				self.organism_var5_dummy.scale = self.organism_var5_sprite.scale
				self.organism_var6_dummy.scale = self.organism_var6_sprite.scale
				self.organism_var7_dummy.scale = self.organism_var7_sprite.scale
				self.organism_var8_dummy.scale = self.organism_var8_sprite.scale
				self.organism_var9_dummy.scale = self.organism_var9_sprite.scale
				self.organism_var10_dummy.scale = self.organism_var10_sprite.scale

	        # Sets all textures in each organism equal to the scale of the organism
			for org in self.experimental_list:
				for texture in org.textures:
					texture.scale = org.scale

					

			#for org in self.histogram_list:
				#for texture in org.textures:
					#texture.scale = org.scale
					


	        
	        # If the scale goes below zero, change it to something teensy but positive
			for i in range(len(self.experimental_list)-1):
				if self.experimental_list[i].scale <= 0:
					self.experimental_list[i].scale = 0.000000001
				print("Scale for var ", i+1,":", self.experimental_list[i].scale)

############## SCALE EVERYONE METHOD HAS BEEN CLEANED #############
    
########################### METHODS RELATED TO FADING IN AND OUT ##################################

	def fade_in(self, target, rate=1):
		# If the target isn't fading in and is already at 255, don't do anything
		if not ((target.fading_in == False) and (target.alpha == 255)):
			# If the target isn't fading in and its alpha is near opaque, keep it there
			if (target.fading_in == False) and (target.alpha >= 245):
				target.alpha = 255

			# If the target is fading in and its alpha is at max, make it zero (start process)
			if (target.fading_in == True) and (target.alpha == 255):
				target.alpha = 0

			# If the targets alpha is greater than 246 (close to max), stop fading in
			if target.alpha >= 246:
				target.fading_in = False

			# If the target's alpha is greater than zero and it's fading in, increase alpha
			if (target.alpha >= 0) and (target.fading_in == True):
				target.alpha += rate

			# If the target's alpha is greater than zero, draw it
		if (target.alpha > 0):
			target.draw()

	def fade_out(self, target, rate=1):
		# If the target is above zero, fade it out
		if target.alpha > 0:
			target.alpha -= 1

		# Only draw the target if it's above zero
		if target.alpha > 0:
			target.draw()

################## BOTH FADE-IN AND FADE-OUT ARE WORKING AS INTENDED ####################



	# A "fade-in-and-out" method; ### CHANGE NAME ONCE EVERYTHING'S WORKING ###
	def fade_in_and_out_better(self, target, rate_in=1, rate_out=1):
		# If the target isn't already fading-out AND is completely transparent:
		if not ((target.fading_out == True) and (target.alpha == 0)):
			# If the target IS still fading in but is completely opaque
			# (i.e. the target hasn't begun yet):

			if (target.fading_in == True) and (target.alpha == 255):
				# Change its opacity to zero so that it can begin the process
			    target.alpha = 0

			# If the target's opacity is zero and it's fading in, starting increasing opacity
			if target.fading_in == True:
				target.alpha += rate_in

			# If the target is still fading in and the opacity is over 240, start fading out
			if (target.fading_in == True) and target.alpha > 240:
				target.fading_in = False
				target.fading_out = True
			
			# If the target is fading out but still has some opacity (>0), reduce opacity
			if (target.fading_out == True) and (target.alpha > 0):
				target.alpha -= rate_out

			# If the target is fading out and its opacity has fallen to or below zero, keep it at zero
			elif (target.fading_out == True) and (target.alpha <= 0):
			    target.alpha = 0

			# Only draw the target when its opacity is greater than zero (to save on memory) 
			if target.alpha > 0:
				target.draw()
		




################# FADE IN AND OUT BETTER METHOD HAS BEEN CLEANED ##############




	def fade_in_sequence(self, target_list, start_range, end_range, rate_in=1, rate_out=5, lower_threshold=100, upper_threshold=255):
		# Start by fading in-and-out the first thing in the list
		# If the start range is zero, just begin with zero
		if start_range == 0:
			self.fade_in_and_out_better(target_list[0], rate_in, rate_out)

		# If the start range is greater than zero, start one before the beginning of the start range
		elif start_range > 0:
			self.fade_in_and_out_better(target_list[start_range-1], rate_in, rate_out)

		# For everything from the start range to the end range:
		for i in range(len(target_list[start_range:end_range])):

			# If the target isn't already at zero opacity and it IS still fading out:
			if not ((target_list[i].alpha == 0) and (target_list[i].fading_out == True)):

				# If the PREVIOUS target is now below the upper threshold of opacity and is fading out:
				if (target_list[i-1].alpha < upper_threshold) and (target_list[i-1].fading_out == True):

					# Begin fading out the target
					self.fade_in_and_out_better(target_list[i], rate_in, rate_out)
				
				# If the target is fading out OR its opacity is not at full, begin the process
				elif (target_list[i].fading_out == True) or (target_list[i].alpha != 255):
					self.fade_in_and_out_better(target_list[i], rate_in, rate_out)


############################## METHODS RELATED TO DRAWING DIALOGUE CHARACTERS ##########################

	def draw_charles_darwin(self):
		# Get the current viewport
		starting_viewport = arcade.get_viewport()

		# Set darwin equal to his right-facing texture
		self.darwin_sprite.set_texture(0)

		if self.current_state < 7:
			# Set Darwin's coordinates on the screen (top left corner of the viewport)
			self.darwin_sprite.center_x = starting_viewport[0] + 100
			self.darwin_sprite.center_y = starting_viewport[2] + 500

		elif self.current_state >= 7:
			self.darwin_sprite.set_texture(1)
			self.darwin_sprite.center_x = self.end_of_level
			# Sets Darwin hovering just at ground-level
			self.darwin_sprite.center_y = self.hist_floor + 70
			

		# Draws Darwin
		# Note:  This will conflict with any fade-in/fade-out effects
		#self.darwin_sprite.draw()

		
#################### DRAW SCENES ########################

### NOTE: Each scene needs to increment to the next scene using the following (increment scene) method:

	def increment_scene(self):
		# Simply adds "1" to the current state to move us forward
		self.current_state += 1


	def draw_opening_screen(self):
		# Get the latest viewport
		viewport = arcade.get_viewport()

		# Get the new dimensions for the logo only if the second phase hasn't started
		if (self.jake_intro == False):
			self.jake.center_x = viewport[0] + 400
			self.jake.center_y = viewport[2] + 300
			# Fade-in-and-out logo
			self.fade_in_and_out_better(self.jake, 2, 2)


		# Once the first logo has faded out, change the image to the warlak and advance
		# Note: the "jake_intro" check ensures that this is only done once
		if (self.jake.alpha == 0) and (self.jake_intro == False):
		    self.jake.set_texture(0)
		    self.jake_intro = True
		    
		    # Be sure to reset Jake's fading status so he can go again, now a warlak
		    self.jake.fading_in = True
		    self.jake.fading_out = False


		    

		# If the intro is complete, move on to the next phase
		elif (self.jake_intro == True) and (self.current_state != 1):  
			
			# Reorient the image slightly for the warlak
			self.jake.center_x = viewport[0] + 400
			self.jake.center_y = viewport[2] + 360
			self.fade_in_and_out_better(self.jake, 2, 2)

			# Don't advance the scene until warlak is invisible
			if self.jake.alpha == 0:
				#self.increment_scene()

				# Plays the pre-loaded intro music (fairy fountain)
				### NOTE:  Hitting "play" repeatedly will cause you grief, so be sure to 
				# Keep this "play()" button where it is (wedged between two scenes)"	
		####################### TURN MUSIC BACK ON WHEN DEBUGGING IS DONE ####################
				mixer.music.play(-1)

				# Advance to the next scene
				self.increment_scene()
					
		# Don't advance until the scene has incremented forward
		if self.current_state == 1:

			# Draw the banner
			self.draw_opening_banner(viewport)

			# Start the intro pokemon loop
			# NOTE: This is only looping TWO pokemon right now!
			# You can cheat, if you must, by adding another Gyarados as a fourth option and incrementing
			# up one.
			self.draw_intro_pokemon_loop(viewport)
			

		


	def draw_opening_banner(self, starting_viewport):
		# Position the banner in the lower-center of the screen
		self.qg_pokemon.center_x = starting_viewport[0] + 370
		self.qg_pokemon.center_y = starting_viewport[2] + 160

		# Fade in the banner
		self.fade_in(self.qg_pokemon)

		
	def draw_intro_pokemon_loop(self, starting_viewport):
		# Position the pokemon
		for i in self.intro_pokemon:
			i.center_x = starting_viewport[0] + 370
			i.center_y = starting_viewport[2] + 400

		# Fade the pokemon in
		self.fade_in_sequence(self.intro_pokemon, 0, 4, lower_threshold = 5, upper_threshold = 10)

		# Run a loop that restarts once the last pokemon has been reached
		for i in range(1):
			# Set the counter at zero
			counter = 0
			for i in self.intro_pokemon:
				# If the pokemon is at lower than 5 opacity, increment
				if i.alpha < 5:
					counter += 1

			# Once you've reached the end of the list of pokemon, restart the fade_in_sequence
			# By resetting the parameters
			if counter >= 3:
				for i in self.intro_pokemon:
					# Reset parameters
					i.fading_in = True
					i.fading_out = False
					i.alpha = 255


	def position_oak_text(self, message):
		# Set the current/newest viewport
		new_viewport = arcade.get_viewport()

		# Give the basic orientatoin for oak text
		message.center_x = new_viewport[0] + 150
		message.center_y = new_viewport[2] + 200


	def draw_prof_oak(self):
		# Get the newest viewport
		starting_viewport = arcade.get_viewport()

		# Orient Professor Oak (Basic/Standard coordinates)
		self.prof_oak.center_x = starting_viewport[0] + 620
		self.prof_oak.center_y = starting_viewport[2] + 100
		    
		# Fade Professor Oak in
		self.fade_in(self.prof_oak)


	def draw_darwin_text(self, message):
		# Gets the current viewport
		new_viewport = arcade.get_viewport()

		# Basic positioning for Darwin text
		message.center_x = new_viewport[0] + 300
		message.center_y = new_viewport[2] + 400

		
	def draw_oak_dialogue_1(self):
		if self.current_state == 3:
			self.draw_prof_oak()
			for message in self.oak1_list:
				self.position_oak_text(message)

	        # Set the coordinates of oak's messages
			self.oak1_list[1].center_y = self.oak1_list[0].center_y - 30
			self.oak1_list[1].center_x = self.oak1_list[0].center_x + 107
			self.oak1_list[2].center_y = self.oak1_list[1].center_y - 35
			self.oak1_list[2].center_x = self.oak1_list[1].center_x + 22

			# Draw/Fade-in the dialogue
			self.fade_in_sequence(self.oak1_list, 1, 4, rate_out=2)
			
			# Begin Darwin's introduction            
			if (self.oak1_list[2].alpha >= 230) and (self.oak1_list[2].alpha < 255):
				self.darwin_dialogue = True

			# Draw Darwin if it's his turn to talk
			if self.darwin_dialogue == True:
                #self.prof_oak_dialogue = False
				self.draw_charles_darwin()
				if not self.HAY_played:
					self.HAY.play()
					self.HAY_played = True

				# In this case, draw Darwin separately because he isn't fading in
				self.darwin_sprite.draw()

				# Check to see if Darwin's played his sound so that it doesn't repeat over and over
				if self.darwin_sound_1_played == False:
					# Load and play Darwin's sound and identify it as played
					#annoyed = arcade.load_sound("sounds/darwin_annoyed.wav")
					#annoyed.play()
					self.darwin_sound_1_played = True


				# Position Darwin's text more specifically
				self.draw_darwin_text(self.oak1_list[3])
				self.draw_darwin_text(self.oak1_list[4])

				# Position Oak's responses
				self.oak1_list[4].center_y -= 40
				self.oak1_list[4].center_x += 50

				# Fade in-and-out Darwin's text
				self.fade_in_and_out_better(self.oak1_list[3], rate_in=6, rate_out=1)
				self.fade_in_and_out_better(self.oak1_list[4], rate_in=3, rate_out=1)

			# Check to see if Darwin's messages are all the way faded in
			if self.oak1_list[4].alpha < 250:

				# Position the rest of Oak's messages with respect to one-another
				self.oak1_list[5].center_x = self.oak1_list[0].center_x + 100
				self.oak1_list[5].center_y = self.oak1_list[0].center_y

				self.oak1_list[6].center_x = self.oak1_list[3].center_x
				self.oak1_list[6].center_y = self.oak1_list[3].center_y

				self.oak1_list[7].center_x = self.oak1_list[3].center_x - 40
				self.oak1_list[7].center_y = self.oak1_list[3].center_y - 40

				self.oak1_list[8].center_x = self.oak1_list[0].center_x + 100
				self.oak1_list[8].center_y = self.oak1_list[0].center_y
                
                
				# Fade in-and-out the last of Oak's thoughts
				self.fade_in_sequence(self.oak1_list, 0, 9, rate_out=4)

				# If the scene hasn't already been advanced, advance it when the messages are done
				if self.oak1_list[8].alpha == 0 and (self.current_state <= 4):
					self.increment_scene()


	def draw_species_selection_text(self):
		# Get the current viewport
		new_viewport = self.get_viewport()

		# Draw Oak (or keep him drawn--he's already onscreen)
		self.draw_prof_oak()
		# Draw Darwin (same)
		self.draw_charles_darwin()

		# Since Darwin isn't drawn by his method, keep him drawn here
		self.darwin_sprite.draw()

		# Give the default positions for oak text
		for message in self.oak2_list:
			self.position_oak_text(message)

		# Re-position Oak text for species selection
		self.oak2_list[0].center_x += 100

		self.oak2_list[1].center_y += 300
		self.oak2_list[1].center_x += 150

		self.oak2_list[2].center_y -= 50
		self.oak2_list[2].center_x += 90

		self.oak2_list[3].center_y -= 100
		self.oak2_list[3].center_x += 80

		# Fade oak text in
		self.fade_in_sequence(self.oak2_list, 0, 4)

		self.prof_oak_dialogue = True

		# Reposition oak text further
		for i in self.oak2_list[3:]:
			i.center_x += 100
			i.center_y += 50

		# Before there's a starter chosen, draw the different pokemon to be selected from 
		self.draw_characters()

		# If a starter has been chosen, give Oak's response
		if self.starter_string:
			for i in self.oak2_list[:4]:
				i.alpha = 0

		# Charmander response				
		if self.starter_string == "charmander":
			self.fade_in_and_out_better(self.oak2_list[4], rate_in=5)

		# Squirtle response
		elif self.starter_string == "squirtle":
			self.fade_in_and_out_better(self.oak2_list[5], rate_in=5)

		# Bulbasaur response
		elif self.starter_string == "bulbasaur":
			self.fade_in_and_out_better(self.oak2_list[6], rate_in=5)
        



		# If there is a starter chosen while in state 4, update scaling with new information
		if self.starter_string and (self.current_state == 4):
    		# Only update scaling if it hasn't already been updated
			if self.scaling_updated == False:
				
				
				# Define all ten histogram sprite images again;
				# This should incorporate the new image (chosen pokemon)
				self.define_all_ten_sprites_images()

				# This should successfully update the scaling values
				self.update_scaling(self.starter_string)

				# This should apply the updated values
				self.scale_everyone()

				# Prevents the scaling from being updated again
				self.scaling_updated = True

				
				
				

		# Advance to the next stage (choosing a focus) if things have incremented properly
		if self.current_state == 5:

			# Render Oak's response from the previous stage invisible and stop drawing it
			for i in self.oak2_list[4:7]:
				i.alpha = 0

			# Keep Darwin on-screen
			self.draw_charles_darwin()
			# Keep Oak on-screen
			self.draw_prof_oak()

			# Oak asks the player to choose from among the population
			# Note: This is currently overlapping with his previous text as well as the
			# leftover charmander/squirtle if chosen (so move them off-screen)
			self.draw_population_choice_text()
     
     		# Give coordinates to the histogram characters
			self.give_hist_coordinates_new(new_viewport)

			# Draw the histogram characters
			self.draw_choosable_histogram()

			# Darwin gets annoyed and moves
			# Check to see if it's already happened
			if self.darwin_sprite.displaced == False:
				self.darwin_gets_displaced()
				# Set the switch to true so it doesn't happen again
				self.darwin_sprite.displaced = True

			# If you've already chosen a column, stop Oak's text
			if self.column_choice > 0:
				for text in self.oak3_list:
					# Set text opacity to zero
					text.alpha = 0

				# Select a focal organism
				self.select_focus_and_advance_to_game()

				# Give Oak's last bit of dialogue
				self.oak_dialogue_pre_game()
			

	def darwin_gets_displaced(self):
		self.darwin_annoyed_sound.play()
		
		# Check to see where Darwin is before moving him
		self.darwin_sprite.change_y = -20
		self.darwin_sprite.draw()

	def draw_population_choice_text(self):
		for i in self.oak3_list:
			self.position_oak_text(i)

			# Note: this has been adjusted to fit the new 10-column histogram
			i.center_x += 150
			i.center_y += 5

		# Darwin's text
		self.oak3_list[4].center_y += 350
		self.oak3_list[4].center_x -= 5

		self.oak3_list[1].center_y -= 50
		self.oak3_list[3].center_y -= 50

		self.fade_in_sequence(self.oak3_list, 0, 6)

	# Gives coordinates to all histogram characters
	def give_hist_coordinates_new(self, current_viewport):
		# Note: These are based on the viewport initially, but are positioned largely relative to
		# one another
		base_x = current_viewport[0] + 370
		base_y = self.hist_floor + 300


		### THE PORTION IN USE BELOW REPRESENTS THE NEW, UPDATED HISTOGRAM WITH TEN COLUMNS 
		# Assigns a column to each sprite so the user can select a phenotype


		# Leftmost organism
		self.organism_var1_sprite.center_y = base_y - 5
		self.organism_var1_sprite.center_x = base_x - 170
		self.organism_var1_sprite.column = 1

		# Second from left
		self.organism_var2_sprite.center_y = base_y - 5
		self.organism_var2_sprite.center_x = base_x - 105
		self.organism_var2_sprite.column = 2

		# Dummy 1
		self.organism_var2_dummy1.center_y = self.organism_var2_sprite.center_y + 50
		self.organism_var2_dummy1.center_x = self.organism_var2_sprite.center_x
		self.organism_var2_dummy1.column = 2



		# Third from left
		self.organism_var3_sprite.center_y = base_y
		self.organism_var3_sprite.center_x = base_x - 40
		self.organism_var3_sprite.column = 3

		# Dummy 1
		self.organism_var3_dummy1.center_y = self.organism_var3_sprite.center_y + 50
		self.organism_var3_dummy1.center_x = self.organism_var3_sprite.center_x
		self.organism_var3_dummy1.column = 3

		# Dummy 2
		self.organism_var3_dummy2.center_y = self.organism_var3_sprite.center_y + 100
		self.organism_var3_dummy2.center_x = self.organism_var3_sprite.center_x
		self.organism_var3_dummy2.column = 3



		# Fourth from left
		self.organism_var4_sprite.center_y = base_y
		self.organism_var4_sprite.center_x = base_x + 25
		self.organism_var4_sprite.column = 4

		# Dummy 1
		self.organism_var4_dummy1.center_y = self.organism_var4_sprite.center_y + 50
		self.organism_var4_dummy1.center_x = self.organism_var4_sprite.center_x
		self.organism_var4_dummy1.column = 4

		# Dummy 2
		self.organism_var4_dummy2.center_y = self.organism_var4_sprite.center_y + 100
		self.organism_var4_dummy2.center_x = self.organism_var4_sprite.center_x
		self.organism_var4_dummy2.column = 4




		# Middle left
		self.organism_var5_sprite.center_y = base_y
		self.organism_var5_sprite.center_x = base_x + 80
		self.organism_var5_sprite.column = 5

		# Dummy 1
		self.organism_var5_dummy1.center_y = self.organism_var5_sprite.center_y + 50
		self.organism_var5_dummy1.center_x = self.organism_var5_sprite.center_x
		self.organism_var5_dummy1.column = 5

		# Dummy 2
		self.organism_var5_dummy2.center_y = self.organism_var5_sprite.center_y + 100
		self.organism_var5_dummy2.center_x = self.organism_var5_sprite.center_x
		self.organism_var5_dummy2.column = 5

		# Dummy 3
		self.organism_var5_dummy3.center_y = self.organism_var5_sprite.center_y + 150
		self.organism_var5_dummy3.center_x = self.organism_var5_sprite.center_x
		self.organism_var5_dummy3.column = 5


		# Middle right
		self.organism_var6_sprite.center_y = base_y
		self.organism_var6_sprite.center_x = base_x + 145
		self.organism_var6_sprite.column = 6

		# Dummy 1
		self.organism_var6_dummy1.center_y = self.organism_var6_sprite.center_y + 50
		self.organism_var6_dummy1.center_x = self.organism_var6_sprite.center_x
		self.organism_var6_dummy1.column = 6

		# Dummy 2
		self.organism_var6_dummy2.center_y = self.organism_var6_sprite.center_y + 100
		self.organism_var6_dummy2.center_x = self.organism_var6_sprite.center_x
		self.organism_var6_dummy2.column = 6

		# Dummy 3
		self.organism_var6_dummy3.center_y = self.organism_var6_sprite.center_y + 150
		self.organism_var6_dummy3.center_x = self.organism_var6_sprite.center_x
		self.organism_var6_dummy3.column = 6



		# Fourth from right
		self.organism_var7_sprite.center_y = base_y
		self.organism_var7_sprite.center_x = base_x + 210
		self.organism_var7_sprite.column = 7

		# Dummy 1
		self.organism_var7_dummy1.center_y = self.organism_var7_sprite.center_y + 50
		self.organism_var7_dummy1.center_x = self.organism_var7_sprite.center_x
		self.organism_var7_dummy1.column = 7

		# Dummy 2
		self.organism_var7_dummy2.center_y = self.organism_var7_sprite.center_y + 100
		self.organism_var7_dummy2.center_x = self.organism_var7_sprite.center_x
		self.organism_var7_dummy2.column = 7



		# Third from right
		self.organism_var8_sprite.center_y = base_y
		self.organism_var8_sprite.center_x = base_x + 275
		self.organism_var8_sprite.column = 8

		# Dummy 1
		self.organism_var8_dummy1.center_y = self.organism_var8_sprite.center_y + 50
		self.organism_var8_dummy1.center_x = self.organism_var8_sprite.center_x
		self.organism_var8_dummy1.column = 8

		# Dummy 2
		self.organism_var8_dummy2.center_y = self.organism_var8_sprite.center_y + 100
		self.organism_var8_dummy2.center_x = self.organism_var8_sprite.center_x
		self.organism_var8_dummy2.column = 8



		# Second from right
		self.organism_var9_sprite.center_y = base_y
		self.organism_var9_sprite.center_x = base_x + 340
		self.organism_var9_sprite.column = 9

		# Dummy 1
		self.organism_var9_dummy1.center_y = self.organism_var9_sprite.center_y + 50
		self.organism_var9_dummy1.center_x = self.organism_var9_sprite.center_x
		self.organism_var9_dummy1.column = 9

		
		# Rightmost organism
		self.organism_var10_sprite.center_y = base_y
		self.organism_var10_sprite.center_x = base_x + 405
		self.organism_var10_sprite.column = 10

		if self.ready_to_breed == True:
			self.organism_var1_dummy.center_x = self.organism_var1_sprite.center_x
			self.organism_var1_dummy.center_y = self.organism_var1_sprite.center_y

			self.organism_var2_dummy.center_x = self.organism_var2_sprite.center_x
			self.organism_var2_dummy.center_y = self.organism_var2_sprite.center_y

			self.organism_var3_dummy.center_x = self.organism_var3_sprite.center_x
			self.organism_var3_dummy.center_y = self.organism_var3_sprite.center_y

			self.organism_var4_dummy.center_x = self.organism_var4_sprite.center_x
			self.organism_var4_dummy.center_y = self.organism_var4_sprite.center_y

			self.organism_var5_dummy.center_x = self.organism_var5_sprite.center_x
			self.organism_var5_dummy.center_y = self.organism_var5_sprite.center_y

			self.organism_var6_dummy.center_x = self.organism_var6_sprite.center_x
			self.organism_var6_dummy.center_y = self.organism_var6_sprite.center_y

			self.organism_var7_dummy.center_x = self.organism_var7_sprite.center_x
			self.organism_var7_dummy.center_y = self.organism_var7_sprite.center_y

			self.organism_var8_dummy.center_x = self.organism_var8_sprite.center_x
			self.organism_var8_dummy.center_y = self.organism_var8_sprite.center_y

			self.organism_var9_dummy.center_x = self.organism_var9_sprite.center_x
			self.organism_var9_dummy.center_y = self.organism_var9_sprite.center_y

			self.organism_var10_dummy.center_x = self.organism_var10_sprite.center_x
			self.organism_var10_dummy.center_y = self.organism_var10_sprite.center_y



	def draw_non_choosable_histogram(self):
        # Assign positions to (and draws) histogram characters
		for i in self.histogram_list:
			i.center_x -= 140
			i.center_y -= 250
			i.fading_in = True
			i.fading_out = False
			i.mating_point = False
			i.point = False
			i.paired_y = ""
			i.paired_x = ""
			# Scale all textures to be equal to the character
			#for texture in i.textures:
			#	texture.scale = i.scale
			# Set all images to face left by default in the histogram
			#i.set_texture(TEXTURE_LEFT)


	def draw_choosable_histogram(self):
        # Assign positions to (and draws) histogram characters
		for i in self.histogram_list:
			i.center_x -= 140
			i.fading_in = True
			i.fading_out = False
			i.jump = i.scale * 300
			# Scale all textures to be equal to the character
			for texture in i.textures:
				texture.scale = i.scale
			# Set all images to face left by default in the histogram
			#i.set_texture(TEXTURE_LEFT)

			if self.column_choice == 0:
				i.draw()
			elif self.column_choice > 0:
				if i.column == self.column_choice:
					# Set this organism as the focal organism
					i.draw()



		# Based on its position, this is a great moment to give these guys their extra textures
		#### COMMENTED-OUT BECAUSE THIS PROBABLY BELONGS IN DEFINITION METHOD ######

		"""
		for i in self.experimental_list:
			# Check to see if the sprite has a textures list, and if it doesn't, make one
			if not i.textures:
				i.textures = []

			# Check to see if this sprite already has its textures
			if len(i.textures) < 2:
				# If the selected pokemon was bulbasaur, load textures
				if self.starter_string == "bulbasaur":
					# Load the left texture
					texture = arcade.load_texture("images/bulbasaur_left.png", i.scale)
					# Add it to the list
					i.textures.append(texture)

					# Load the right texture
					texture = arcade.load_texture("images/bulbasaur_right.png", i.scale)
					# Add it to the list
					i.textures.append(texture)
				
				# Do the same for charmander
				elif self.starter_string == "charmander":
					# Load the left texture
					texture = arcade.load_texture("images/charmander_left.png", i.scale)
					# Add it to the list
					i.textures.append(texture)

					# Load the right texture
					texture = arcade.load_texture("images/charmander_right.png", i.scale)
					# Add it to the list
					i.textures.append(texture)

				# Do the same for squirtle
				elif self.starter_string == "squirtle":
					# Load the left texture
					texture = arcade.load_texture("images/squirtle_left.png", i.scale)
					# Add it to the list
					i.textures.append(texture)

					# Load the right texture
					texture = arcade.load_texture("images/squirtle_right.png", i.scale)
					# Add it to the list
					i.textures.append(texture)
					"""


	# Gives a scaling update based on the pokemon chosen
	def update_scaling(self, starter_string):
		print("Current level: ", self.level)
		new_mean = pop_keeper.mean_phenotypic_trait_value_list[self.level-1]
		new_var = pop_keeper.additive_genetic_variance_list[self.level-1]
		# If bulbasaur is chosen, set the variance and standard deviation
		if "bulbasaur" == starter_string:
			# If level one, adjust scaling to line up with the starting (ancestral) mean
			if self.level == 1:
				self.CHARACTER_SCALING = bulbasaur_scaling * starting_mean
				self.var = self.var * bulbasaur_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)

			# If this process takes place after the first level, change the scaling appropriately
			elif self.level > 1:
				print("Current character scaling: ", self.CHARACTER_SCALING)
				self.CHARACTER_SCALING = bulbasaur_scaling * new_mean
				self.var = new_var * bulbasaur_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)

		# If charmander is selected, set the variance and standard deviation
		elif "charmander" == starter_string:
			# If level one, adjust scaling to line up with the starting (ancestral) mean
			if self.level == 1:
				self.CHARACTER_SCALING = charmander_scaling * starting_mean
				self.var = self.var * charmander_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)

			# If this process takes place after the first level, change the scaling appropriately
			elif self.level > 1:
				self.CHARACTER_SCALING = charmander_scaling * new_mean
				print("charmander updated!")
				self.var = new_var * charmander_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)
	
		# If squirtle is chosen, set the variance and standard deviation
		elif "squirtle" == starter_string:
			# If level one, adjust scaling to line up with the starting (ancestral) mean
			if self.level == 1:
				self.CHARACTER_SCALING = squirtle_scaling * starting_mean
				self.var = self.var * squirtle_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)

			# If this process takes place after the first level, change the scaling appropriately
			elif self.level > 1:
				self.CHARACTER_SCALING = squirtle_scaling * new_mean
				self.var = new_var * squirtle_scaling * var_scalar
				self.std_dev = numpy.sqrt(self.var)
		
		# In the event that the variance is negative (or zero), set it to a teensy number instead
		if self.var <= 0:
			self.var = 0.00000001

		# Same for standard deviation (though this wouldn't happen if variance were already positive)
		# It's slightly plausible that std_dev would become zero through rounding error, though.
		if self.std_dev <= 0:
			self.std_dev = 0.000000001

	# Draw the pokemon species available to choose in Professor Oak's dialogue
	def draw_characters(self):
		# Get the current viewport
		current_viewport = self.get_viewport()

		# Properly scale the bulbasaur example
		bulbasaur = arcade.Sprite("images/bulbasaur_left.png", bulbasaur_scaling*5)

		# Properly scale the charmander example
		charmander = arcade.Sprite("images/charmander_left.png", charmander_scaling*5)

		# Properly scale the squirtle example
		squirtle = arcade.Sprite("images/squirtle_left.png", squirtle_scaling*6)

		# Append all three pokemon to a "starters list" to make them easy to identify
		self.starters_list = arcade.SpriteList()

		# While no one's been chosen, draw all three
		if not self.starter_string:
			self.starters_list.append(bulbasaur)
			self.starters_list.append(charmander)
			self.starters_list.append(squirtle)   
		
		elif (self.starter_string) and (self.current_state == 4):
			# Add bulbasaur to the list if it's been chosen (draw it)
			if self.starter_string == "bulbasaur":
				self.starters_list.append(bulbasaur)

			# Add charmander to the list if he's been chosen (draw it)
			elif self.starter_string == "charmander":
				self.starters_list.append(charmander)

			# Add squirtle to the list if he's been chosen (draw it)
			elif self.starter_string == "squirtle":
				self.starters_list.append(squirtle)

		# Set bulbasaur's coordinates on-screen
		bulbasaur.center_x = int(current_viewport[0] + 120)
		bulbasaur.center_y = int(current_viewport[2] + 350)

		# Set bulbasaur's coordinates on-screen
		charmander.center_x = int(current_viewport[0] + 370)
		charmander.center_y = int(current_viewport[2] + 350)

		# Set bulbasaur's coordinates on-screen
		squirtle.center_x = int(current_viewport[0] + 620)
		squirtle.center_y = int(current_viewport[2] + 350)

		# Draw the pokemon
		self.starters_list.draw()

	def select_focus_and_advance_to_game(self):
		# Look through the ten organisms in the experimental list and choose the one from the column...
		# ...selected
		for org in self.experimental_list:

			# If the column is equal to the player's choice, choose that organism as focus
			if self.column_choice == org.column:
				org = self.focal_organism


	def oak_dialogue_pre_game(self):
		for i in self.oak4_list:
			self.position_oak_text(i)

			# Note: this has been adjusted to fit the new 10-column histogram
			i.center_x += 150
			i.center_y += 5

		# A shorthand
		oak4 = self.oak4_list

		# Hold's Oak's response to your choice
		selected_text = []

		### Get Oak to respond based on the column you chose ###

		# If you chose the smallest
		if self.column_choice == 1:
			selected_text.append(oak4[0])
			
		# Second smallest
		elif self.column_choice == 2:
			selected_text.append(oak4[1])

		# Below average size
		elif (self.column_choice == 3) or (self.column_choice == 4):
			selected_text.append(oak4[2])

		# Average size
		elif (self.column_choice == 5) or (self.column_choice == 6):
			selected_text.append(oak4[3])

		# Above average size
		elif (self.column_choice == 7) or (self.column_choice == 8):
			selected_text.append(oak4[4])

		# Second largest or largest
		elif (self.column_choice == 9) or (self.column_choice == 10):
			selected_text.append(oak4[5])


		# Oak reads "Interesting" and "Let's go" no matter what
		selected_text.append(oak4[6])
		selected_text.append(oak4[7])


		self.fade_in_sequence(selected_text, 0, 3)

	# Draws everything in the game
	def on_draw(self):
		# Start drawing/rendering objects on the screen
		arcade.start_render()

		
		
		# Begin the opening sequence
		# If the stage is earlier than 2
		if self.current_state < 2:
			self.draw_opening_screen()

		# Print the first bout of Professor Oa's dialogue (introduction)
		if self.current_state >= 2:
			self.draw_oak_dialogue_1()

		# Begin Professor Oak's dialogue about choosing a species
		if (self.current_state == 4) or (self.current_state == 5):
			self.draw_species_selection_text()

		# Catalyze the start of the game if we're on stage 6
		if self.current_state == 6:
			self.start_game = True
			

		# Now that we're starting the game, we should pick a focal organism (to begin with)
		if (self.start_game == True) and (self.current_state == 6):
			if self.column_choice:
				
				# Check to see if this organism is the one who was selected
				for org in self.player_list:
					if org.column == self.column_choice:
						self.focal_organism = org
						self.focal_organism_physics_engine = arcade.PhysicsEnginePlatformer(self.focal_organism, self.wall_list, GRAVITY)
				

			self.increment_scene()
			print(self.current_state)

		#if self.level_complete == True:
			# Make professor oak invisible until he's next drawn
		#	self.start_new_level(self.level)

		if (not self.player_list) and (self.level_complete == False) and (self.current_state >= 7):
			self.go_extinct()

			if self.extinction:
				extinction_text = f"EXTINCTION!"
				arcade.draw_text(extinction_text, 200 + self.view_left, 200 + self.view_bottom, 
				             arcade.csscolor.WHITE, 60)

		if self.current_state >= 7:
			self.draw_game()
			if self.go_to_next_level == True:
				self.start_new_level(self.level)






	
	def draw_mean_and_var_text(self):
		new_viewport = arcade.get_viewport()

		mean_text = f"Average size: {str(pop_keeper.mean_phenotypic_trait_value_list[self.level-1])[:4]}"
		var_text = f"Additive genetic variance: {str(pop_keeper.additive_genetic_variance_list[self.level-1])[:4]}"

		arcade.draw_text(mean_text, new_viewport[0] + 450, new_viewport[2] + 500, 
		                 arcade.csscolor.WHITE, 10)


		arcade.draw_text(var_text, new_viewport[0] + 450, new_viewport[2] + 480, 
		                 arcade.csscolor.WHITE, 10)
		



	def draw_game(self):
		
		arcade.start_render()

		self.wall_list.draw()
		


		if self.ready_to_breed == False and (self.level_complete == False):
			self.player_list.draw()

		# Draw the current mean and variance
		self.draw_mean_and_var_text()


		# Draw all the enemies
		self.enemy_list.draw()

		# Draw Darwin at the end
		# Draw Darwin at his new coordinates
		self.draw_charles_darwin()
		self.darwin_list.draw()


		# Only while we're in the level, draw this
		#if (self.level_complete == False) and (self.ready_to_breed == False):
			# Draw all walls and non-active objects
		


		if (self.level_complete == True) and (self.selection_calculated == False):
			# Calculate who died
			self.calculate_losses()


		# Check the effect of selection and get a new generation
			self.get_change_after_selection()
			self.ready_to_breed = True
			self.selection_calculated = True

		if self.ready_to_breed == True:
			viewport = arcade.get_viewport()

			self.breeding = True
			if self.breeding_histogram_drawn == False and (self.breeding == True):
				self.define_all_ten_sprites_images()
				self.give_hist_coordinates_new(viewport)
				#self.breed()
				self.scale_everyone()
				self.draw_non_choosable_histogram()
				self.breeding = False
				
				self.breeding_histogram_drawn = True
			
			for i in self.histogram_list:
				
				self.fade_in(i)

				self.go_to_next_level = True
				self.level_complete = False



	


				
				

			





		#elif (self.level_complete == True) and (self.ready_to_breed == True):
		#	viewport = arcade.get_viewport()
			#self.wall_list.draw()
		#	print("STuck on three!")
		#	self.give_hist_coordinates_new(viewport)
		#	self.draw_choosable_histogram()
		#	self.experimental_list.draw()
		#	self.breed()
		#	self.heart_list.draw()
		


	def honeymoon(self):
		self.honeymoon_ready = True
		new_viewport = arcade.get_viewport()
		random_mating = "Random Mating!"
		arcade.draw_text(random_mating, new_viewport[0] + 450, new_viewport[2] + 500, 
		                 arcade.csscolor.WHITE, 40)
		for i in self.experimental_list:
		    i.change_y = 5

		for heart in self.heart_list:
		    if heart.has_point == False:
		        heart.center_x = numpy.random.randint(new_viewport[0]-100, new_viewport[1]-200)
		        heart.center_y = numpy.random.randint(new_viewport[2], new_viewport[3])
		        heart.has_point = True
		    if heart.growing == True:
		        heart.scale += 0.001
		    elif heart.growing == False:
		        heart.scale -= 0.001
		    if heart.scale <= 0.01:
		        heart.growing = True
		    elif heart.scale >= 0.04:
		        heart.growing = False


	def breed(self):
		current_viewport = arcade.get_viewport()
		if self.current_music != self.love_music:
		    self.current_music = self.love_music
		    mixer.init()
		    mixer.music.load(self.love_music)
		    mixer.music.play()
		    mixer.music.fadeout(6000)
		    print("Should've played!")

		#self.honeymoon_ready = True
		self.set_breeding_coordinates(current_viewport)

		for i in range(len(self.histogram_list)):
		    
			g = i - 1

			if not self.histogram_list[g] == self.focal_organism:
				breeding_coordinates = self.breeding_coordinates

				if self.histogram_list[g].mating_point == False:
					# Establish semi-permanent mating coordinates for each organism
					self.histogram_list[g].point = numpy.random.randint(0, len(breeding_coordinates))

			    
				# Shorthand
				point = self.histogram_list[g].point


				print("This guy's point: ", point)

				# Flip a switch so that all organisms don't continue to get new points
				if breeding_coordinates[point] not in self.used_coords:
				    self.histogram_list[g].mating_point = True


				# If you reach the coordinate, stop moving left and right
				if self.histogram_list[g].center_x == breeding_coordinates[point][0]:
				    self.histogram_list[g].change_x = 0
				    self.histogram_list[g].paired_x = True

				# If the coordinate is to your left, move left
				elif self.histogram_list[g].center_x > (breeding_coordinates[point][0]):
				    self.histogram_list[g].change_x = -5

				# If the coordinate is to your right, move right
				elif self.histogram_list[g].center_x < (breeding_coordinates[point][0]):
				    self.histogram_list[g].change_x = 5

				# If the coordinate is below you, move south
				if self.histogram_list[g].center_y > (breeding_coordinates[point][1]):
				    self.histogram_list[g].change_y = -5

				# If the coordinate is above you, move up
				elif self.histogram_list[g].center_y < (breeding_coordinates[point][1]):
				    self.histogram_list[g].change_y = 5
				else:
					# If you've reached the coordinate, stay there
				    self.histogram_list[g].change_y = 0
				    self.histogram_list[g].paired_y = True

		    

			self.used_coords.append(breeding_coordinates[point])
		if not self.paired_count >= 5:
		    self.paired_count = 0

		    for i in self.histogram_list:
		        if (i.paired_y and i.paired_x) == True:
		            self.paired_count += 1
		    print("Pre-honeymoon but really close!")

		if self.paired_count >= len(self.histogram_list):
		    print("At the honeymoon!")
		    self.honeymoon()
			
	def set_breeding_coordinates(self, viewport):
		print("I've set the breeding_coordinates!")

		left = viewport[0]
		width = viewport[1] 
		bot = viewport[2]
		height = viewport[3]

		self.breeding_coordinates = [
		        # First pair
		        
		        # Left
		        [left + 500, 100],
		        #Right
		        [left + 550, 100],

		        # Second pair

		        # Left
		        [left + 150, 200],
		        #Right
		        [left + 200, 200],

		        # Third pair

		        # Left
		        [left + 250, 450],
		        #Right
		        [left + 300, 450],

		        # Fourth pair

		        # Left
		        [left + 260, 300],
		        #Right
		        [left + 310, 300],

		        # Fifth pair

		        # Left
		        [left + 320, 100],
		        #Right
		        [left + 370, 100]

        ]


	def advance_to_oak_intro(self):
		# Increment to the oak intro
		self.increment_scene()

		# Play the select sound
		self.select.play()
		# Fade music as you transition into stage 2
		mixer.music.fadeout(3000)
		# Load the pokemon medley for Professor Oak's big entry
		medley = mixer.music.load(self.pokemon_medley)
		

############ TURN MUSIC BACK ON WHEN DEBUGGING IS DONE (BE SURE TO CHECK KEYPRESS TOO!) ##########
		mixer.music.play(-1)

################### MOUSE COMMANDS #####################

	def on_mouse_press(self, x, y, button, modifiers):
		# If we're in stage four...
		if self.current_state == 4:
			# Check if left mouse button was used
			if button == arcade.MOUSE_BUTTON_LEFT:

				# Checks to see if each of the three pokemon was selected by the mouse
				bulbasaur_check = self.starters_list[0].collides_with_point((x, y))
				charmander_check = self.starters_list[1].collides_with_point((x, y))
				squirtle_check = self.starters_list[2].collides_with_point((x, y))

				# If there's not yet a starter chosen...
				if len(self.starter_string) < 1:
					if bulbasaur_check == True:
						
						# If bulbasaur was chosen, change the string and starter image
						self.starter_organism = self.starter_organism_dict["bulbasaur"]
						
						# Changes the starter string to reflect bulbasaur
						self.starter_string = "bulbasaur"

						# Play the select sound when chosen
						self.select.play()
						
					# If charmander was chosen, change the starter string and starter image
					elif charmander_check == True:

						# If charmander was chosen, change the string and starter image
						self.starter_organism = self.starter_organism_dict["charmander"]

						# Changes the starter string to reflect charmander
						self.starter_string = "charmander"

						# Play the select sound when chosen
						self.select.play()

					elif squirtle_check == True:

						# If squirtle was chosen, change the string and starter image
						self.starter_organism = self.starter_organism_dict["squirtle"]

						# Changes the starter string to reflect squirtle
						self.starter_string = "squirtle"

						# Plays the select noise if they were chosen
						self.select.play()
			
		# Checks to see if we're in the right phase for choosing a focus
		if self.current_state == 5:

			# Only do this if a choice hasn't already been made
			if self.column_choice == 0:

				# Looks through the histogram list to see if any sprite has been selected
				for i in self.histogram_list:
					# Makes a variable that returns a boolean (True/False) that says whether or not
					# the indiividual has been selected
					new_check = i.collides_with_point((x, y))

					# If the organism is selected, play a sound
					if new_check == True:

						# Play the select noise
						self.select.play()

						# Sets the player's choice equal to the column the organism is in
						self.column_choice = i.column

						# Sets up the focal organism for later use
						for org in self.player_list:
							if self.column_choice == org.column:
								self.focal_organism = org
						print("Picked a focus!")


                    

################## KEYBOARD COMMANDS ######################
	def on_key_press(self, key, modifiers):
		current_viewport = arcade.get_viewport()

		if self.current_state == 1:
			# Press either enter or escape to advance
			if (key == arcade.key.ESCAPE) or (key == arcade.key.ENTER):
			
				# Increment the scene
				self.increment_scene()
				# Begin Professor Oak's intro
				self.advance_to_oak_intro()
				# Play music on a loop
				
		############ TURN MUSIC BACK ON WHEN DEBUGGING IS DONE ##########

				mixer.music.play(-1)

		# This is intended to allow the user to use enter or escape to skip scenes
		if (self.current_state == 3):
			# If escape is pressed, skip ahead
			if (key == arcade.key.ESCAPE):
				self.increment_scene()

		# Let the player hit enter to advance to scene five to prevent dialogue overlap
		if (self.current_state == 4) or (self.current_state == 5):

			if (key == arcade.key.ENTER):
				# Advance the scene on enter key-press
				self.increment_scene()

		# If we're currently in-game
		if self.current_state == 7:
			# When the "down" key is pressed
			if key == arcade.key.DOWN or key == arcade.key.S:
				# Go down (if applicable) at a speed equal to the constant set at the beginning
				# Check all organisms
				for org in self.player_list:
					org.change_y = -int(ORGANISM_MEAN_MOVEMENT_SPEED)

########### FOR IN-GAME CONTROL ##############

			if key == arcade.key.UP or key == arcade.key.W:
				for org in self.player_list:
					if org.physics_engine.can_jump():
						org.change_y = org.jump

			# When the left key is pressed
			if key == arcade.key.LEFT or key == arcade.key.A:
				# Check all organisms
				for org in self.player_list:
					# Go right at a speed equal to the constant set at the beginning
					org.change_x = -int(ORGANISM_MEAN_MOVEMENT_SPEED)
					

			# When the right key is pressed
			if key == arcade.key.RIGHT or key == arcade.key.D:
				# Check all organisms
				for org in self.player_list:
					# Go right at a speed equal to the constant set at the beginning
					org.change_x = int(ORGANISM_MEAN_MOVEMENT_SPEED)

			if key == arcade.key.KEY_1:
			    if self.organism_var1_sprite in self.player_list:
			        self.focal_organism = self.organism_var1_sprite
			        print("Key noted!")
			if key == arcade.key.KEY_2:
			    if self.organism_var2_sprite in self.player_list:
			        self.focal_organism = self.organism_var2_sprite
			if key == arcade.key.KEY_3:
			    if self.organism_var3_sprite in self.player_list:
			        self.focal_organism = self.organism_var3_sprite
			if key == arcade.key.KEY_4:
			    if self.organism_var4_sprite in self.player_list:
			        self.focal_organism = self.organism_var4_sprite
			if key == arcade.key.KEY_5:
			    if self.organism_var5_sprite in self.player_list:
			        self.focal_organism = self.organism_var5_sprite
			        print("Key noted!")
			if key == arcade.key.KEY_6:
			    if self.organism_var6_sprite in self.player_list:
			        self.focal_organism = self.organism_var6_sprite
			if key == arcade.key.KEY_7:
			    if self.organism_var7_sprite in self.player_list:
			        self.focal_organism = self.organism_var7_sprite
			if key == arcade.key.KEY_8:
			    if self.organism_var8_sprite in self.player_list:
			        self.focal_organism = self.organism_var8_sprite
			if key == arcade.key.KEY_9:
			    if self.organism_var9_sprite in self.player_list:
			        self.focal_organism = self.organism_var9_sprite
			if key == arcade.key.KEY_0:
			    if self.organism_var10_sprite in self.player_list:
			        self.focal_organism = self.organism_var10_sprite

			self.focal_organism.alpha = 255

			for org in self.player_list:
				if org != self.focal_organism:
					org.alpha = 50

			# Start enemies moving the moment a player presses a key
			if key:
				# Check all enemies
				for enemy in self.enemy_list:
					# Change the x
					enemy.change_x = int(enemy.speed)
					enemy.change_y = int(numpy.random.randint(0,20))

					# If the enemy 
					if (enemy.center_x > self.darwin_sprite.center_x) or (enemy.center_y < current_viewport[2]) or (enemy.center_y > (current_viewport[2] + current_viewport[3])):
					    enemy.remove_from_sprite_lists()


					


	def on_key_release(self, key, modifiers):
		""" Called whenever a key is pressed. """

		if key == arcade.key.UP or key == arcade.key.W:
			for org in self.player_list:
				org.change_y = 0

		if key == arcade.key.DOWN or key == arcade.key.S:
			for org in self.player_list:
				org.change_y = 0


		if key == arcade.key.LEFT or key == arcade.key.A:
			for org in self.player_list:
				org.change_x = 0


		if key == arcade.key.RIGHT or key == arcade.key.D:
			for org in self.player_list:
				org.change_x = 0

	


	def update(self, delta_time):
		if self.current_state == 7:

			if self.ready_to_breed:
				self.histogram_list.update()


			if self.focal_organism not in self.player_list:
				# Pick a random, existing player who's still alive to change to
				if len(self.player_list) > 1:
					random_selection = numpy.random.randint(0, len(self.player_list)-1)

					# The randomly selected player becomes the new focal organism
					self.focal_organism = self.player_list[random_selection]
				elif len(self.player_list) == 1:
					self.focal_organism = self.player_list[0]

				else:
					self.extinction = True
				
			# Run all the physics engines for players except during the breeding time
			if self.ready_to_breed == False:
				for engine in self.player_physics_engines_list:
					engine.update()

			# Update the position et al of the enemies
			for engine in self.enemy_physics_engine_list:
				engine.update()

			# Makes a master list for enemies to use in hitting walls to go around them.
			enemy_wall_hit_list_master = []

			for enemy in self.enemy_list:
				enemy_hit_list = arcade.check_for_collision_with_list(enemy, self.wall_list)
				enemy_wall_hit_list_master.append(enemy_hit_list)

			



			### Check for interaction between enemy and player ###
			# Make a master list to be referenced in a loop
			player_master_hit_hist = []

			# Make the same for Darwin
			master_darwin_list = []

			### Check Darwin for hits ###

			# Make a hit list for all players
			for i in self.player_list:

				# Make a hit list for each player and darwin
				darwin_hit_list = arcade.check_for_collision_with_list(i, self.darwin_list)
				# Append these to a master list
				master_darwin_list.append(darwin_hit_list)

            # When they reach Darwin
			for darwin_hit_list in master_darwin_list:

				# If they hit Darwin
				for darwin in darwin_hit_list:
					

					########## TURN BACK ON WHEN DEBUGGING IS FINISHED ############

					mixer.music.fadeout(5000)

					# Remove Darwin from themap
					darwin.remove_from_sprite_lists()

					# Reset the player list
					self.player_list = arcade.SpriteList()

                
				for player in darwin_hit_list:
				    #player.remove_from_sprite_lists()
				    if (self.level_complete == False) and (self.debriefing == False):
				        self.level_complete = True
				        
				        print("LEVEL OVER!")

			# Check each enemy for hits
			for enemy in self.enemy_list:

				# Create a new list for each enemy 
			    player_hit_list = arcade.check_for_collision_with_list(enemy, self.player_list)
			    
			    # Add that list to the master list
			    player_master_hit_hist.append(player_hit_list)

                # Check each hit list to see if the player was hit
			for player_hit_list in player_master_hit_hist:
				
				# Check all players
				for player in player_hit_list:
					
					# Check to see if the player is already dead (i.e. still in player_list)
					if player in self.player_list:

						# Set this player as dead
						player.dead = True

			            # Remove the player if they were hit
						self.select.play()
						player.remove_from_sprite_lists()




			if self.level_complete == False:
				
########### THIS MUST BE PLACED IN UPDATE IN ORDER TO PROPERLY FOLLOW THE SCREEN ############

				# Track if we need to change the viewport
				changed = False

				### NOTE: ALL OF THIS IS CURRENTLY WORKING CORRECTLY, BUT SOMETHING'S WRONG WITH WINDOW SIZING; FIX THIS TO MAKE SCROLLING WORK PROPERLY ###
				# Solved the above by inreasing the right viewport margin (in "constants" section above initializer)

				# Scroll left
				left_boundary = self.view_left + LEFT_VIEWPORT_MARGIN
				if self.focal_organism.left < left_boundary:
				    self.view_left -= left_boundary - self.focal_organism.left
				    changed = True

				# Scroll right
				right_boundary = self.view_left + SCREEN_WIDTH - RIGHT_VIEWPORT_MARGIN
				if (self.focal_organism.right) > right_boundary:
				    self.view_left += self.focal_organism.right - right_boundary
				    changed = True

				# Scroll up
				top_boundary = self.view_bottom + SCREEN_HEIGHT - TOP_VIEWPORT_MARGIN
				if self.focal_organism.top > top_boundary:
				    self.view_bottom += self.focal_organism.top - top_boundary
				    changed = True

				# Scroll down
				bottom_boundary = self.view_bottom + BOTTOM_VIEWPORT_MARGIN
				if self.focal_organism.bottom < bottom_boundary:
				    self.view_bottom -= bottom_boundary - self.focal_organism.bottom
				    changed = True

				if changed:
				    # Only scroll to integers--otherwise we end up with pixels
				    # that don't line up on the screen
				    self.view_bottom = int(self.view_bottom)
				    self.view_left = int(self.view_left)

				    # Do the sscrolling
				    arcade.set_viewport(self.view_left,
				                        SCREEN_WIDTH + self.view_left,
				                        self.view_bottom,
				                        SCREEN_HEIGHT + self.view_bottom)



	def go_extinct(self):
		print("Extinct!")
		self.extinction = True


	def start_new_level(self, level):

		self.ready_to_breed = True
		
		viewport = arcade.get_viewport()
		self.define_all_ten_sprites_images()
		self.give_hist_coordinates_new(viewport)
		self.draw_non_choosable_histogram()
		self.scale_everyone()
		for i in self.histogram_list:
			for texture in i.textures:
				texture.scale = i.scale
		self.histogram_list.draw()
		self.ready_to_breed = False
		if self.ready_to_breed == False:
			# Resets this for the next go-around
			self.go_to_next_level = False
			

			#self.get_change_after_selection()
			self.level += 1
			self.setup(level, self.CHARACTER_SCALING)
			self.new_mean = pop_keeper.mean_phenotypic_trait_value_list[self.level-1]
			self.current_state = 6
			self.define_all_ten_sprites_images()
			self.update_scaling(self.starter_string)
			self.scale_everyone()
			for i in self.player_list:
				if self.starter_string == "bulbasaur":
					i.jump = i.scale * 300
				elif self.starter_string == "charmander":
					i.jump = i.scale * 300
				elif self.starter_string == "squirtle":
					i.jump = i.scale * 150
			
			self.make_enemies(self.level)

			self.end_of_level = self.level * 1000



	# Determine who died
	def calculate_losses(self):
	    self.loss_list = [
	    self.pop_0_alive,
	    self.pop_1_alive,
	    self.pop_2_alive,
	    self.pop_3_alive,
	    self.pop_4_alive,
	    self.pop_5_alive,
	    self.pop_6_alive,
	    self.pop_7_alive,
	    self.pop_8_alive,
	    self.pop_9_alive,
	    ]

	    if self.organism_var1_sprite.dead == True:
	        self.loss_list[0] = False
	    if self.organism_var2_sprite.dead == True:
	        self.loss_list[1] = False
	    if self.organism_var3_sprite.dead == True:
	        self.loss_list[2] = False
	    
	    if self.organism_var4_sprite.dead == True:
	        self.loss_list[3] = False
	    if self.organism_var5_sprite.dead == True:
	        self.loss_list[4] = False
	    if self.organism_var6_sprite.dead == True:
	        self.loss_list[5] = False

	    if self.organism_var7_sprite.dead == True:
	        self.loss_list[6] = False
	    if self.organism_var8_sprite.dead == True:
	        self.loss_list[7] = False
	    if self.organism_var9_sprite.dead == True:
	        self.loss_list[8] = False
	    if self.organism_var10_sprite.dead == True:
	        self.loss_list[9] = False


	def get_change_after_selection(self):

		# Use the simulation to calculate the effects of selection
		sim.select_via_player(pop_keeper.current_gen, self.loss_list, pop_keeper)

		print(self.loss_list)
		
		# Use the simulation to produce a new generation based on the survivors
		sim.funcs.reproduce(pop_keeper, sim.classes.Organism)

		# Use the simulation to evaluate the new generation
		sim.funcs.evaluate_population(pop_keeper.current_gen, pop_keeper, sim.starter_species, sim.starter_trait)

		# Get the new mean of the population
		new_mean = pop_keeper.mean_phenotypic_trait_value_list[self.level-1]
		
		# Set Character scaling equal to the new mean
		self.CHARACTER_SCALING = new_mean

		print(pop_keeper.mean_phenotypic_trait_value_list)

		

		

# Main method of the game; calls set-up initially 
# Call set-up again to run another level
def main():
    """ Main method """
    window = MyGame()
    print("initialized!")
    window.setup(window.level)
    print("Just ran setup!")
    arcade.run()


# Calls method to run the game/page
if __name__ == "__main__":
    main()
